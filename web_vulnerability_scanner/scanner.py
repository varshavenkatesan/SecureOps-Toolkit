#!/usr/bin/env python3
"""
Web Application Vulnerability Scanner
======================================
Detects common web vulnerabilities including SQL Injection and XSS.

Author: Varsha Venkatesan
Purpose: Educational - Authorized Security Testing Only

⚠️ WARNING: Only scan applications you own or have explicit permission to test!
"""

import requests
import urllib.parse
from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
import time
import sys

# Import payloads
from payloads import (
    SQL_INJECTION_PAYLOADS,
    SQL_ERROR_SIGNATURES,
    XSS_PAYLOADS,
    XSS_DETECTION_SIGNATURES,
    COMMON_VULNERABLE_PARAMS
)


class WebVulnerabilityScanner:
    """
    Scanner for detecting SQL Injection and XSS vulnerabilities in web applications.
    """
    
    def __init__(self, target_url, timeout=10):
        """
        Initialize the vulnerability scanner.
        
        Args:
            target_url (str): Target URL to scan
            timeout (int): Request timeout in seconds
        """
        self.target_url = target_url
        self.timeout = timeout
        self.vulnerabilities = []
        
        # Configure session for connection reuse
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'SecureOps-Scanner/1.0 (Educational Purpose)',
        })
    
    def validate_url(self):
        """
        Validate the target URL format.
        
        Returns:
            bool: True if valid, False otherwise
        """
        try:
            result = urlparse(self.target_url)
            return all([result.scheme, result.netloc])
        except:
            return False
    
    def test_sql_injection(self, test_params=None):
        """
        Test for SQL Injection vulnerabilities.
        
        Args:
            test_params (list): List of parameter names to test (optional)
        """
        print("\n" + "="*60)
        print("TESTING FOR SQL INJECTION")
        print("="*60)
        
        # Parse URL to extract parameters
        parsed_url = urlparse(self.target_url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        params = parse_qs(parsed_url.query)
        
        # If no parameters in URL, use common parameter names
        if not params:
            if test_params:
                params = {param: ['test'] for param in test_params}
            else:
                print("[*] No parameters found in URL")
                print("[*] Testing with common parameter names...")
                params = {param: ['test'] for param in COMMON_VULNERABLE_PARAMS[:5]}
        
        print(f"[*] Testing {len(params)} parameter(s)")
        print(f"[*] Using {len(SQL_INJECTION_PAYLOADS)} SQL injection payloads")
        
        vuln_count = 0
        
        # Test each parameter
        for param_name in params:
            print(f"\n[*] Testing parameter: {param_name}")
            
            # Test each payload
            for payload in SQL_INJECTION_PAYLOADS:
                try:
                    # Create modified parameters
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    # Build test URL
                    query_string = urlencode(test_params, doseq=True)
                    test_url = f"{base_url}?{query_string}"
                    
                    # Send request
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        allow_redirects=True
                    )
                    
                    # Check for SQL error signatures in response
                    response_text = response.text.lower()
                    
                    for error_sig in SQL_ERROR_SIGNATURES:
                        if error_sig in response_text:
                            vuln_count += 1
                            vuln_info = {
                                'type': 'SQL Injection',
                                'parameter': param_name,
                                'payload': payload,
                                'error_signature': error_sig,
                                'url': test_url
                            }
                            self.vulnerabilities.append(vuln_info)
                            
                            print(f"  [!] VULNERABILITY DETECTED!")
                            print(f"      Parameter: {param_name}")
                            print(f"      Payload: {payload}")
                            print(f"      Error: {error_sig}")
                            
                            # Don't test more payloads for this parameter
                            break
                    
                    # Small delay to avoid overwhelming the server
                    time.sleep(0.1)
                    
                except requests.exceptions.RequestException as e:
                    print(f"  [-] Request failed: {str(e)[:50]}")
                    continue
                except KeyboardInterrupt:
                    print("\n[!] Scan interrupted by user")
                    return
        
        if vuln_count == 0:
            print("\n[+] No SQL Injection vulnerabilities detected")
        else:
            print(f"\n[!] Found {vuln_count} potential SQL Injection vulnerability(ies)")
    
    def test_xss(self, test_params=None):
        """
        Test for Cross-Site Scripting (XSS) vulnerabilities.
        
        Args:
            test_params (list): List of parameter names to test (optional)
        """
        print("\n" + "="*60)
        print("TESTING FOR CROSS-SITE SCRIPTING (XSS)")
        print("="*60)
        
        # Parse URL to extract parameters
        parsed_url = urlparse(self.target_url)
        base_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}"
        params = parse_qs(parsed_url.query)
        
        # If no parameters in URL, use common parameter names
        if not params:
            if test_params:
                params = {param: ['test'] for param in test_params}
            else:
                print("[*] No parameters found in URL")
                print("[*] Testing with common parameter names...")
                params = {param: ['test'] for param in COMMON_VULNERABLE_PARAMS[:5]}
        
        print(f"[*] Testing {len(params)} parameter(s)")
        print(f"[*] Using {len(XSS_PAYLOADS)} XSS payloads")
        
        vuln_count = 0
        
        # Test each parameter
        for param_name in params:
            print(f"\n[*] Testing parameter: {param_name}")
            
            # Test a subset of payloads (to avoid too many requests)
            for payload in XSS_PAYLOADS[:10]:  # Test first 10 payloads
                try:
                    # Create modified parameters
                    test_params = params.copy()
                    test_params[param_name] = [payload]
                    
                    # Build test URL
                    query_string = urlencode(test_params, doseq=True)
                    test_url = f"{base_url}?{query_string}"
                    
                    # Send request
                    response = self.session.get(
                        test_url,
                        timeout=self.timeout,
                        allow_redirects=True
                    )
                    
                    # Check if payload is reflected in response
                    response_text = response.text
                    
                    # Check for exact payload reflection
                    if payload in response_text:
                        vuln_count += 1
                        vuln_info = {
                            'type': 'Cross-Site Scripting (XSS)',
                            'parameter': param_name,
                            'payload': payload,
                            'reflection': 'Exact payload reflected',
                            'url': test_url
                        }
                        self.vulnerabilities.append(vuln_info)
                        
                        print(f"  [!] VULNERABILITY DETECTED!")
                        print(f"      Parameter: {param_name}")
                        print(f"      Payload: {payload[:50]}...")
                        print(f"      Status: Payload reflected in response")
                        
                        # Don't test more payloads for this parameter
                        break
                    
                    # Check for partial reflection (signatures)
                    for signature in XSS_DETECTION_SIGNATURES:
                        if signature in response_text and signature in payload:
                            vuln_count += 1
                            vuln_info = {
                                'type': 'Potential XSS',
                                'parameter': param_name,
                                'payload': payload,
                                'reflection': f'Partial reflection detected: {signature}',
                                'url': test_url
                            }
                            self.vulnerabilities.append(vuln_info)
                            
                            print(f"  [!] POTENTIAL VULNERABILITY!")
                            print(f"      Parameter: {param_name}")
                            print(f"      Payload: {payload[:50]}...")
                            print(f"      Status: Partial reflection ({signature})")
                            break
                    
                    # Small delay to avoid overwhelming the server
                    time.sleep(0.1)
                    
                except requests.exceptions.RequestException as e:
                    print(f"  [-] Request failed: {str(e)[:50]}")
                    continue
                except KeyboardInterrupt:
                    print("\n[!] Scan interrupted by user")
                    return
        
        if vuln_count == 0:
            print("\n[+] No XSS vulnerabilities detected")
        else:
            print(f"\n[!] Found {vuln_count} potential XSS vulnerability(ies)")
    
    def generate_report(self):
        """
        Generate a detailed vulnerability report.
        """
        print("\n" + "="*60)
        print("VULNERABILITY SCAN REPORT")
        print("="*60)
        
        print(f"\nTarget URL: {self.target_url}")
        print(f"Scan Date: {time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Total Vulnerabilities Found: {len(self.vulnerabilities)}")
        
        if not self.vulnerabilities:
            print("\n[+] No vulnerabilities detected!")
            print("[+] The application appears to be secure against tested attacks.")
        else:
            print("\n[!] VULNERABILITIES DETECTED:")
            print("-"*60)
            
            for i, vuln in enumerate(self.vulnerabilities, 1):
                print(f"\n{i}. {vuln['type']}")
                print(f"   Parameter: {vuln['parameter']}")
                print(f"   Payload: {vuln['payload']}")
                
                if 'error_signature' in vuln:
                    print(f"   Evidence: {vuln['error_signature']}")
                elif 'reflection' in vuln:
                    print(f"   Evidence: {vuln['reflection']}")
                
                print(f"   URL: {vuln['url'][:80]}...")
        
        print("\n" + "="*60)
        print("RECOMMENDATIONS")
        print("="*60)
        
        if any(v['type'] == 'SQL Injection' for v in self.vulnerabilities):
            print("\n[!] SQL Injection Detected:")
            print("    - Use parameterized queries/prepared statements")
            print("    - Implement input validation and sanitization")
            print("    - Use ORM frameworks")
            print("    - Apply least privilege to database users")
        
        if any('XSS' in v['type'] for v in self.vulnerabilities):
            print("\n[!] XSS Detected:")
            print("    - Encode all user input before displaying")
            print("    - Implement Content Security Policy (CSP)")
            print("    - Use HTTPOnly and Secure flags for cookies")
            print("    - Validate and sanitize all input")
        
        print("\n" + "="*60)


def main():
    """
    Main function to run the Web Vulnerability Scanner interactively.
    """
    print("\n" + "="*60)
    print("WEB APPLICATION VULNERABILITY SCANNER")
    print("="*60)
    
    print("\n⚠️  ETHICAL USAGE WARNING ⚠️")
    print("This tool is for AUTHORIZED testing only!")
    print("Only scan applications you own or have permission to test.")
    print("Unauthorized scanning is illegal and unethical.\n")
    
    # Get target URL
    target_url = input("Enter target URL to scan: ").strip()
    
    if not target_url:
        print("[!] No URL provided. Exiting.")
        return
    
    # Add http:// if no scheme provided
    if not target_url.startswith(('http://', 'https://')):
        target_url = 'http://' + target_url
    
    # Initialize scanner
    scanner = WebVulnerabilityScanner(target_url)
    
    # Validate URL
    if not scanner.validate_url():
        print(f"[!] Invalid URL format: {target_url}")
        return
    
    print(f"\n[*] Target: {target_url}")
    
    # Confirmation
    confirm = input("\n[?] Confirm you have authorization to scan this target (yes/no): ").strip().lower()
    
    if confirm != 'yes':
        print("[!] Scan cancelled. Authorization not confirmed.")
        return
    
    print("\n[*] Starting vulnerability scan...")
    print("[*] This may take a few minutes depending on the target...")
    
    try:
        # Test for SQL Injection
        scanner.test_sql_injection()
        
        # Test for XSS
        scanner.test_xss()
        
        # Generate report
        scanner.generate_report()
        
    except KeyboardInterrupt:
        print("\n\n[!] Scan interrupted by user")
        scanner.generate_report()
    except Exception as e:
        print(f"\n[ERROR] Scan failed: {e}")
    
    print("\n[*] Scan complete!")


if __name__ == "__main__":
    main()
